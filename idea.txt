Conflict resolution

When a segment fails to construct any path, it may be because
rooms necessary for the connection were consumed by a previous segment

in this case, the previous segment consumed an edge, IE it took the last path from an edge type
if it did not, then it is impossible for a failed segment to succeed if we undid that previous segment

each segment in succession removes 0 or more edges from the graph
if we can detect which edges were removed each time
and which are necessary to make the failed segment succeed
then we can resolve the conflict

all we need to do is make the conflicting segment use a different path that does
not consume the necessary edges

so each segment should record the state of the graph at the time, which edges it consumed
segments made after do not necessariyl have to be revokved, as long as the edges they consumed are not
necessary ot find a path in the latest segment


So for a failed segment, look at a previous segment
and all removed edges up to that point

for all segments removed edges see if some combination of them being readded
could fulfill the failed edge

if so, see if we can find satisfactory combinations for both of these segmetns

if so, good, if not, go back a prev segmetn and try again

the question is, which edges do we reflow our active graphs with?
which combination of them can we be sure will lead to a successful path?

at the least, the current prev_segment includes all edges of future ones already
so we can look at the current prev_segment for an AF path, then check if it conflicts with any
future segments
and if no path that doesnt conflict exist, then go back one and try again?
>>>maybe we can make some conclusion if such a non-conflicting path doesnte xist

and we go back we include more edges,
eventually at some point wed have to try "redoing" the paths
so future edges get remade some other way sow e dont have a conflcit?

but at what point should we detect taht?

we should try minmially, so ASAP
with every segment alwys try rebuilding conflicting future segments too?

at the initial case
we have current segment N which failed
and prev segment N - 1 which succeeded

if prev segment N-1 conflicts with current segment we can rebuild or go back 
if we CANT rebuild, then we go back

go back to N-2
Now we see if we can rebuild N-2 WITHOUT rebuilding N-1 to create a nonconflicting path

It might eb that both N-2 and N-1 need to be rebuilt to not conflict
assuming that N-1 DID in fact conflict originally (if it didnt rebuilding it will haev no effect?)
But may only N-2 needs to be rebuilt
if we failed N-1 we might not be able to say that it will never be needed

what makes a segment conflict?
If rebuilding it refunds an edge that can be used to make N succeed

What if multiple edges are needed to make N succeed
but such edges were consumed by different Segments?

DUNNO

If we see that different edges A and B were consumed by AN and BN

then we can try the combination A, B to see if N succeeds
If so, then we have to try rebuild AN and BN in a way that does not consume A, B

we also try independently if only A or only B succeeds

we also remember which combinations have been tried before so if a previous segment AN2 that conumes A
wait that doesnt make sense, if an edge is consumed by AN it cant be consumed by a different N

alright so just try uniquine never before tried combinations

So with each iteration back we add some number of edges X
which adds some number of combinations, but we already tried some
so maybe it wont be so bad
but what is the running time?

===
Algorithm
===

When segment N fails to complete

For every segment before it S

	Add edges consumed by S to Edges

	For every unique combination of edges (Should be like N choose K from 1 to N) 
		#can we reduce the amount we tests? 
		#can we make some logic to tell before flowing if a combination will be unique from another?

		see if N does NOT fail if those edges are added to N.G 
		#should be super fast since we can just see if there's a shortest path
		#though also we haev to reflow for every combo so thats a little cost

		If some not fail was found, test if we can remix all segments consuming those edges
		in a way that refunds the necessary edges while still being able to maintain all segments

		#would have to account for paths removed by room consumption
		#would need way to detect which part of a segment should be redon
		#in case: path used was only type, may have to redo entire segment
		#in case: edge consumed's last edge was part of other room, may be able to only replace the path put there

OKAY now we also have to account for rooms removed from a path other than the type used and all rooms that did that
so maybe a room in a different segment removed one of 2 paths and we can possibly replace that one instead
hard to say...


We have to do some better way to connect and construct segments
we have to like, do it all at once or something
but we dont want to try ALL segments or something

best case: we can resume any segment's loop to try every edge after that
but it also needs to dynamically account for every room being consumed as its consumed

i dont think doing simultaneously would work because the flow and shortest steps needs to not be misled
by suddenly removing an edge that was originally going to evenutlaly be part of our current path

maybe we should give up conflict resolution and just decide that if we cant find a path then its hopeless

OKAY in order for a path to possibly have an alternative possible shortest path, there must have been a time that 
we could have branched to another shortest path but we wouldnt be able to tell if this branch
eventually leads to the consumed edge anyways :think:

	
===
Actual solution
===
Prioritize paths that dont consuem edges
we can do this by hiding edges that have only one path left (and associated rooms with that path)
then when we find path only use those hidden edges if absolutely necessary, and try to use the minimum amount of them

we should remove and hide edeg in the same step that chooses a path
and unhide it if we ever unchoose that path (so when readding check if removede edge or hidden edge)

in our algorithm we have two options: try to find A F without edges then with edges
OR try to find A F for ANY AF combo before retrying all combos with edges

I think what we can do is pass "possible AF" combos or list with a "AF picker" that extracts the necessary AF
in a custom function that then passes the AF and edgeless or edgeful graph to the actual find path

this func will return the chosen AF and path
